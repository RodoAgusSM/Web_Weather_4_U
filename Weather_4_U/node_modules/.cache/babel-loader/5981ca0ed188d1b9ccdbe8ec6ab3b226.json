{"ast":null,"code":"import * as t from \"fs\";\nimport * as i from \"path\";\nimport { decode as r } from \"geobuf\";\nimport e from \"@turf/boolean-point-in-polygon\";\nimport { point as o } from \"@turf/helpers\";\nimport f from \"pbf\";\nvar n = [{\n  tzid: \"Etc/GMT-12\",\n  left: 172.5,\n  right: 180\n}, {\n  tzid: \"Etc/GMT-11\",\n  left: 157.5,\n  right: 172.5\n}, {\n  tzid: \"Etc/GMT-10\",\n  left: 142.5,\n  right: 157.5\n}, {\n  tzid: \"Etc/GMT-9\",\n  left: 127.5,\n  right: 142.5\n}, {\n  tzid: \"Etc/GMT-8\",\n  left: 112.5,\n  right: 127.5\n}, {\n  tzid: \"Etc/GMT-7\",\n  left: 97.5,\n  right: 112.5\n}, {\n  tzid: \"Etc/GMT-6\",\n  left: 82.5,\n  right: 97.5\n}, {\n  tzid: \"Etc/GMT-5\",\n  left: 67.5,\n  right: 82.5\n}, {\n  tzid: \"Etc/GMT-4\",\n  left: 52.5,\n  right: 67.5\n}, {\n  tzid: \"Etc/GMT-3\",\n  left: 37.5,\n  right: 52.5\n}, {\n  tzid: \"Etc/GMT-2\",\n  left: 22.5,\n  right: 37.5\n}, {\n  tzid: \"Etc/GMT-1\",\n  left: 7.5,\n  right: 22.5\n}, {\n  tzid: \"Etc/GMT\",\n  left: -7.5,\n  right: 7.5\n}, {\n  tzid: \"Etc/GMT+1\",\n  left: -22.5,\n  right: -7.5\n}, {\n  tzid: \"Etc/GMT+2\",\n  left: -37.5,\n  right: -22.5\n}, {\n  tzid: \"Etc/GMT+3\",\n  left: -52.5,\n  right: -37.5\n}, {\n  tzid: \"Etc/GMT+4\",\n  left: -67.5,\n  right: -52.5\n}, {\n  tzid: \"Etc/GMT+5\",\n  left: -82.5,\n  right: -67.5\n}, {\n  tzid: \"Etc/GMT+6\",\n  left: -97.5,\n  right: -82.5\n}, {\n  tzid: \"Etc/GMT+7\",\n  left: -112.5,\n  right: -97.5\n}, {\n  tzid: \"Etc/GMT+8\",\n  left: -127.5,\n  right: -112.5\n}, {\n  tzid: \"Etc/GMT+9\",\n  left: -142.5,\n  right: -127.5\n}, {\n  tzid: \"Etc/GMT+10\",\n  left: -157.5,\n  right: -142.5\n}, {\n  tzid: \"Etc/GMT+11\",\n  left: -172.5,\n  right: -157.5\n}, {\n  tzid: \"Etc/GMT+12\",\n  left: -180,\n  right: -172.5\n}];\n\nfunction d(t) {\n  if (-180 === t || 180 === t) return [\"Etc/GMT+12\", \"Etc/GMT-12\"];\n\n  for (var i = [], r = 0; r < n.length; r++) {\n    var e = n[r];\n    if (e.left <= t && e.right >= t) i.push(e.tzid);else if (e.right < t) break;\n  }\n\n  return i;\n}\n\nvar a,\n    l = require(\"../data/index.json\"),\n    c = i.join(__dirname, \"..\", \"data\", \"geo.dat\");\n\nfunction h(i) {\n  if (a = i && i.store && \"function\" == typeof i.store.get && \"function\" == typeof i.store.set ? i.store : new Map(), i && i.preload) {\n    var r = t.openSync(c, \"r\");\n    if (r < 0) throw new Error(\"Failed to open geo.dat file\");\n    !function (t) {\n      !function i(r, e) {\n        if (r.pos >= 0 && r.len) {\n          var o = g(0, r.pos, r.len, t);\n          a.set(e, o);\n        } else \"object\" == typeof r && Object.getOwnPropertyNames(r).forEach(function (t) {\n          i(r[t], e + t);\n        });\n      }(l.lookup, \"\");\n    }(r), t.closeSync(r);\n  }\n}\n\nfunction g(i, e, o, n) {\n  void 0 === n && (n = -1);\n  var d = n;\n  if (d < 0 && (d = t.openSync(c, \"r\")) < 0) throw new Error(\"Failed to open geo.dat file\");\n  var a = Buffer.alloc(o),\n      l = t.readSync(d, a, 0, o, e);\n  if (n < 0 && t.closeSync(d), l < o) throw new Error(\"tried to read \" + o + \" bytes from geo.dat but only got \" + l + \" bytes\");\n  var h = new f(a);\n  return r(h);\n}\n\nfunction p(t, i) {\n  var r = i;\n  if (isNaN(t) || t > 90 || t < -90) throw new Error(\"Invalid latitude: \" + t);\n  if (isNaN(i) || i > 180 || i < -180) throw new Error(\"Invalid longitude: \" + i);\n  if (90 === t) return n.map(function (t) {\n    return t.tzid;\n  });\n  t >= 89.9999 ? t = 89.9999 : t <= -89.9999 && (t = -89.9999), i >= 179.9999 ? i = 179.9999 : i <= -179.9999 && (i = -179.9999);\n\n  for (var f = o([i, t]), c = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0\n  }, h = \"\", p = l.lookup;;) {\n    var m = void 0;\n    if (t >= c.midLat && i >= c.midLon ? (m = \"a\", c.bottom = c.midLat, c.left = c.midLon) : t >= c.midLat && i < c.midLon ? (m = \"b\", c.bottom = c.midLat, c.right = c.midLon) : t < c.midLat && i < c.midLon ? (m = \"c\", c.top = c.midLat, c.right = c.midLon) : (m = \"d\", c.top = c.midLat, c.left = c.midLon), h += m, !(p = p[m])) return d(r);\n\n    if (p.pos >= 0 && p.len) {\n      var u = a.get(h);\n      u || (u = g(0, p.pos, p.len), a.set(h, u));\n\n      for (var s = [], E = 0; E < u.features.length; E++) e(f, u.features[E]) && s.push(u.features[E].properties.tzid);\n\n      return s.length > 0 ? s : d(r);\n    }\n\n    if (p.length > 0) return p.map(function (t) {\n      return l.timezones[t];\n    });\n    if (\"object\" != typeof p) throw new Error(\"Unexpected data type\");\n    c.midLat = (c.top + c.bottom) / 2, c.midLon = (c.left + c.right) / 2;\n  }\n}\n\nfunction m() {\n  h({\n    preload: !0\n  });\n}\n\nh();\nexport { p as find, m as preCache, h as setCache };","map":{"version":3,"sources":["../src/oceanUtils.ts","../src/find.ts"],"names":["oceanZones","tzid","left","right","getTimezoneAtSea","lon","tzs","i","length","z","push","tzData","require","FEATURE_FILE_PATH","path","join","__dirname","featureCache","cacheLevel","options","store","get","set","Map","preload","featureFileFd","fs","openSync","Error","_preCache","closeSync","preloadFeaturesRecursive","curTzData","quadPos","pos","len","geoJson","loadFeatures","Object","getOwnPropertyNames","forEach","value","lookup","fd","buf","Buffer","alloc","bytesRead","readSync","data","Pbf","decode","find","lat","originalLon","isNaN","map","zone","pt","point","quadData","top","bottom","midLat","midLon","nextQuad","timezonesContainingPoint","features","inside","properties","idx","timezones","preCache"],"mappings":";;;;;;IAMaA,CAAAA,GAA0B,CACrC;EAAEC,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAM,KAA5B;EAAmCC,KAAAA,EAAO;AAA1C,CADqC,EAErC;EAAEF,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAM,KAA5B;EAAmCC,KAAAA,EAAO;AAA1C,CAFqC,EAGrC;EAAEF,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAM,KAA5B;EAAmCC,KAAAA,EAAO;AAA1C,CAHqC,EAIrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,KAA3B;EAAkCC,KAAAA,EAAO;AAAzC,CAJqC,EAKrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,KAA3B;EAAkCC,KAAAA,EAAO;AAAzC,CALqC,EAMrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CANqC,EAOrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CAPqC,EAQrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CARqC,EASrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CATqC,EAUrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CAVqC,EAWrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,IAA3B;EAAiCC,KAAAA,EAAO;AAAxC,CAXqC,EAYrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAM,GAA3B;EAAgCC,KAAAA,EAAO;AAAvC,CAZqC,EAarC;EAAEF,IAAAA,EAAM,SAAR;EAAmBC,IAAAA,EAAAA,CAAO,GAA1B;EAA+BC,KAAAA,EAAO;AAAtC,CAbqC,EAcrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAdqC,EAerC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAfqC,EAgBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAhBqC,EAiBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAjBqC,EAkBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAlBqC,EAmBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,IAA5B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAnBqC,EAoBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,KAA5B;EAAmCC,KAAAA,EAAAA,CAAQ;AAA3C,CApBqC,EAqBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,KAA5B;EAAmCC,KAAAA,EAAAA,CAAQ;AAA3C,CArBqC,EAsBrC;EAAEF,IAAAA,EAAM,WAAR;EAAqBC,IAAAA,EAAAA,CAAO,KAA5B;EAAmCC,KAAAA,EAAAA,CAAQ;AAA3C,CAtBqC,EAuBrC;EAAEF,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAAA,CAAO,KAA7B;EAAoCC,KAAAA,EAAAA,CAAQ;AAA5C,CAvBqC,EAwBrC;EAAEF,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAAA,CAAO,KAA7B;EAAoCC,KAAAA,EAAAA,CAAQ;AAA5C,CAxBqC,EAyBrC;EAAEF,IAAAA,EAAM,YAAR;EAAsBC,IAAAA,EAAAA,CAAO,GAA7B;EAAkCC,KAAAA,EAAAA,CAAQ;AAA1C,CAzBqC,C;;AAyBK,SAS5BC,CAT4B,CASXC,CATW,EASXA;EAE/B,IAAA,CAAa,GAAb,KAAIA,CAAJ,IAA4B,QAARA,CAApB,EACE,OAAO,CAAC,YAAD,EAAe,YAAf,CAAP;;EAGF,KADA,IAAMC,CAAAA,GAAM,EAAZ,EACSC,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAIP,CAAAA,CAAWQ,MAA/B,EAAuCD,CAAAA,EAAvC,EAA4C;IAC1C,IAAME,CAAAA,GAAIT,CAAAA,CAAWO,CAAXP,CAAV;IACA,IAAIS,CAAAA,CAAEP,IAAFO,IAAUJ,CAAVI,IAAiBA,CAAAA,CAAEN,KAAFM,IAAWJ,CAAhC,EACEC,CAAAA,CAAII,IAAJJ,CAASG,CAAAA,CAAER,IAAXK,EADF,KACaL,IACFQ,CAAAA,CAAEN,KAAFM,GAAUJ,CADRJ,EAEX;EAGJ;;EAAA,OAAOK,CAAP;AC5CF;;AAAA,IAGIW,CAHJ;AAAA,IAAMN,CAAAA,GAASC,OAAAA,CAAQ,oBAARA,CAAf;AAAA,IAEMC,CAAAA,GAAoBC,CAAAA,CAAKC,IAALD,CAAUE,SAAVF,EAAqB,IAArBA,EAA2B,MAA3BA,EAAmC,SAAnCA,CAF1B;;AAsBA,SAASI,CAAT,CAAoBC,CAApB,EAAoBA;EAWlB,IAJEF,CAAAA,GALAE,CAAAA,IACAA,CAAAA,CAAQC,KADRD,IAE6B,cAAA,OAAtBA,CAAAA,CAAQC,KAARD,CAAcE,GAFrBF,IAG6B,cAAA,OAAtBA,CAAAA,CAAQC,KAARD,CAAcG,GAHrBH,GAKeA,CAAAA,CAAQC,KALvBD,GAOe,IAAII,GAAJ,EAFfN,EAIEE,CAAAA,IAAWA,CAAAA,CAAQK,OAAvB,EAAgC;IAC9B,IAAMC,CAAAA,GAAgBC,CAAAA,CAAGC,QAAHD,CAAYb,CAAZa,EAA+B,GAA/BA,CAAtB;IAEA,IAAID,CAAAA,GAAgB,CAApB,EACE,MAAA,IAAUG,KAAV,CAAgB,6BAAhB,CAAA;IAAgB,CAiBtB,UAAmBH,CAAnB,EAAmBA;MAAAA,CAEjB,SAASM,CAAT,CAAkCC,CAAlC,EAA6CC,CAA7C,EAA6CA;QAC3C,IAAID,CAAAA,CAAUE,GAAVF,IAAiB,CAAjBA,IAAsBA,CAAAA,CAAUG,GAApC,EAAyC;UACvC,IAAMC,CAAAA,GAAUC,CAAAA,CACdJ,CADcI,EAEdL,CAAAA,CAAUE,GAFIG,EAGdL,CAAAA,CAAUG,GAHIE,EAIdZ,CAJcY,CAAhB;UAMApB,CAAAA,CAAaK,GAAbL,CAAiBgB,CAAjBhB,EAA0BmB,CAA1BnB;QAA0BmB,CAP5B,MAQgC,YAAA,OAAdJ,CAAc,IAC9BM,MAAAA,CAAOC,mBAAPD,CAA2BN,CAA3BM,EAAsCE,OAAtCF,CAA8C,UAAUG,CAAV,EAAUA;UACtDV,CAAAA,CAAyBC,CAAAA,CAAUS,CAAVT,CAAzBD,EAA2CE,CAAAA,GAAUQ,CAArDV,CAAAA;QAAqDU,CADvDH,CAD8B;MAMlCP,CAfA,CAeyBpB,CAAAA,CAAO+B,MAfhC,EAewC,EAfxC,CAFiBjB;IAdfI,CAcJ,CAdcJ,CAcd,CAjBsB,EAKlBC,CAAAA,CAAGI,SAAHJ,CAAaD,CAAbC,CALkB;EAKLD;AA2CjB;;AAAA,SAASY,CAAT,CACEJ,CADF,EAEEC,CAFF,EAGEC,CAHF,EAIEQ,CAJF,EAIEA;EAAAA,KAAAA,CAAAA,KAAAA,CAAAA,KAAAA,CAAAA,GAAAA,CAAc,CAAdA;EAEA,IAAIlB,CAAAA,GAAgBkB,CAApB;EACA,IAAIlB,CAAAA,GAAgB,CAAhBA,IAAgB,CAClBA,CAAAA,GAAgBC,CAAAA,CAAGC,QAAHD,CAAYb,CAAZa,EAA+B,GAA/BA,CADE,IAEE,CAFtB,EAGI,MAAA,IAAUE,KAAV,CAAgB,6BAAhB,CAAA;EAMJ,IAAMgB,CAAAA,GAAMC,MAAAA,CAAOC,KAAPD,CAAaV,CAAbU,CAAZ;EAAA,IACME,CAAAA,GAAYrB,CAAAA,CAAGsB,QAAHtB,CAAYD,CAAZC,EAA2BkB,CAA3BlB,EAAgC,CAAhCA,EAAmCS,CAAnCT,EAAwCQ,CAAxCR,CADlB;EAQA,IAJIiB,CAAAA,GAAK,CAALA,IACFjB,CAAAA,CAAGI,SAAHJ,CAAaD,CAAbC,CADEiB,EAIAI,CAAAA,GAAYZ,CAAhB,EACE,MAAA,IAAUP,KAAV,CAAUA,mBACSO,CADTP,GACSO,mCADTP,GACgDmB,CADhDnB,GACgDmB,QAD1D,CAAA;EAKF,IAAME,CAAAA,GAAO,IAAIC,CAAJ,CAAQN,CAAR,CAAb;EACA,OAAOO,CAAAA,CAAOF,CAAPE,CAAP;AAAcF;;AAAAA,SAUAG,CAVAH,CAUKI,CAVLJ,EAUkB5C,CAVlB4C,EAUkB5C;EAChC,IAAMiD,CAAAA,GAAcjD,CAApB;EAKA,IAAIkD,KAAAA,CAAMF,CAANE,CAAAA,IAAcF,CAAAA,GAAM,EAApBE,IAA0BF,CAAAA,GAAAA,CAAO,EAArC,EAEE,MADM,IAAIzB,KAAJ,CAAU,uBAAuByB,CAAjC,CACN;EAIF,IAAIE,KAAAA,CAAMlD,CAANkD,CAAAA,IAAclD,CAAAA,GAAM,GAApBkD,IAA2BlD,CAAAA,GAAAA,CAAO,GAAtC,EAEE,MADM,IAAIuB,KAAJ,CAAU,wBAAwBvB,CAAlC,CACN;EAIF,IAAY,OAARgD,CAAJ,EACE,OAAOrD,CAAAA,CAAWwD,GAAXxD,CAAe,UAACyD,CAAD,EAACA;IAAAA,OAASA,CAAAA,CAAKxD,IAAdwD;EAAcxD,CAA9BD,CAAP;EAIEqD,CAAAA,IAAO,OAAPA,GACFA,CAAAA,GAAM,OADJA,GAEOA,CAAAA,IAAAA,CAAQ,OAARA,KACTA,CAAAA,GAAAA,CAAO,OADEA,CAFPA,EAMAhD,CAAAA,IAAO,QAAPA,GACFA,CAAAA,GAAM,QADJA,GAEOA,CAAAA,IAAAA,CAAQ,QAARA,KACTA,CAAAA,GAAAA,CAAO,QADEA,CARPgD;;EAwBJ,KAZA,IAAMK,CAAAA,GAAKC,CAAAA,CAAM,CAACtD,CAAD,EAAMgD,CAAN,CAANM,CAAX,EACMC,CAAAA,GAAW;IACfC,GAAAA,EAAK,OADU;IAEfC,MAAAA,EAAAA,CAAS,OAFM;IAGf5D,IAAAA,EAAAA,CAAO,QAHQ;IAIfC,KAAAA,EAAO,QAJQ;IAKf4D,MAAAA,EAAQ,CALO;IAMfC,MAAAA,EAAQ;EANO,CADjB,EASI/B,CAAAA,GAAU,EATd,EAUID,CAAAA,GAAYrB,CAAAA,CAAO+B,MAEvB,IAAa;IAEX,IAAIuB,CAAAA,GAAAA,KAAAA,CAAJ;IAyBA,IAxBIZ,CAAAA,IAAOO,CAAAA,CAASG,MAAhBV,IAA0BhD,CAAAA,IAAOuD,CAAAA,CAASI,MAA1CX,IACFY,CAAAA,GAAW,GAAXA,EACAL,CAAAA,CAASE,MAATF,GAAkBA,CAAAA,CAASG,MAD3BE,EAEAL,CAAAA,CAAS1D,IAAT0D,GAAgBA,CAAAA,CAASI,MAHvBX,IAIOA,CAAAA,IAAOO,CAAAA,CAASG,MAAhBV,IAA0BhD,CAAAA,GAAMuD,CAAAA,CAASI,MAAzCX,IACTY,CAAAA,GAAW,GAAXA,EACAL,CAAAA,CAASE,MAATF,GAAkBA,CAAAA,CAASG,MAD3BE,EAEAL,CAAAA,CAASzD,KAATyD,GAAiBA,CAAAA,CAASI,MAHjBX,IAIAA,CAAAA,GAAMO,CAAAA,CAASG,MAAfV,IAAyBhD,CAAAA,GAAMuD,CAAAA,CAASI,MAAxCX,IACTY,CAAAA,GAAW,GAAXA,EACAL,CAAAA,CAASC,GAATD,GAAeA,CAAAA,CAASG,MADxBE,EAEAL,CAAAA,CAASzD,KAATyD,GAAiBA,CAAAA,CAASI,MAHjBX,KAKTY,CAAAA,GAAW,GAAXA,EACAL,CAAAA,CAASC,GAATD,GAAeA,CAAAA,CAASG,MADxBE,EAEAL,CAAAA,CAAS1D,IAAT0D,GAAgBA,CAAAA,CAASI,MAPhBX,CARPA,EAqBJpB,CAAAA,IAAWgC,CArBPZ,EAqBOY,EAFXjC,CAAAA,GAAYA,CAAAA,CAAUiC,CAAVjC,CAEDiC,CAGX,EAEE,OAAO7D,CAAAA,CAAiBkD,CAAjBlD,CAAP;;IAAwBkD,IACftB,CAAAA,CAAUE,GAAVF,IAAiB,CAAjBA,IAAsBA,CAAAA,CAAUG,GADjBmB,EACsB;MAE9C,IAAIlB,CAAAA,GAAUnB,CAAAA,CAAaI,GAAbJ,CAAiBgB,CAAjBhB,CAAd;MACKmB,CAAAA,KACHA,CAAAA,GAAUC,CAAAA,CAAaJ,CAAbI,EAAsBL,CAAAA,CAAUE,GAAhCG,EAAqCL,CAAAA,CAAUG,GAA/CE,CAAVD,EACAnB,CAAAA,CAAaK,GAAbL,CAAiBgB,CAAjBhB,EAA0BmB,CAA1BnB,CAFGmB,CAAAA;;MAOL,KAFA,IAAM8B,CAAAA,GAA2B,EAAjC,EAES3D,CAAAA,GAAI,CAAb,EAAgBA,CAAAA,GAAI6B,CAAAA,CAAQ+B,QAAR/B,CAAiB5B,MAArC,EAA6CD,CAAAA,EAA7C,EACM6D,CAAAA,CAAOV,CAAPU,EAAWhC,CAAAA,CAAQ+B,QAAR/B,CAAiB7B,CAAjB6B,CAAXgC,CAAAA,IACFF,CAAAA,CAAyBxD,IAAzBwD,CAA8B9B,CAAAA,CAAQ+B,QAAR/B,CAAiB7B,CAAjB6B,EAAoBiC,UAApBjC,CAA+BnC,IAA7DiE,CADEE;;MAON,OAAOF,CAAAA,CAAyB1D,MAAzB0D,GAAkC,CAAlCA,GACHA,CADGA,GAEH9D,CAAAA,CAAiBkD,CAAjBlD,CAFJ;IAEqBkD;;IAAAA,IACZtB,CAAAA,CAAUxB,MAAVwB,GAAmB,CADPsB,EAGrB,OAAOtB,CAAAA,CAAUwB,GAAVxB,CAAc,UAACsC,CAAD,EAACA;MAAAA,OAAQ3D,CAAAA,CAAO4D,SAAP5D,CAAiB2D,CAAjB3D,CAAR2D;IAAyBA,CAAxCtC,CAAP;IAA+CsC,IACjB,YAAA,OAAdtC,CAD+BsC,EAI/C,MADM,IAAI1C,KAAJ,CAAU,sBAAV,CACN;IAIFgC,CAAAA,CAASG,MAATH,GAASG,CAAUH,CAAAA,CAASC,GAATD,GAAeA,CAAAA,CAASE,MAAlCC,IAA4C,CAArDH,EACAA,CAAAA,CAASI,MAATJ,GAASI,CAAUJ,CAAAA,CAAS1D,IAAT0D,GAAgBA,CAAAA,CAASzD,KAAnC6D,IAA4C,CADrDJ;EACqD;AAAA;;AAAA,SASzCY,CATyC,GASzCA;EACdtD,CAAAA,CAAW;IAAEM,OAAAA,EAAAA,CAAS;EAAX,CAAXN,CAAAA;AAvMFA;;AAAAA,CAAAA;AAAAA,SAAAA,CAAAA,IAAAA,IAAAA,EAAAA,CAAAA,IAAAA,QAAAA,EAAAA,CAAAA,IAAAA,QAAAA","sourcesContent":["type OceanZone = {\n  left: number\n  right: number\n  tzid: string\n}\n\nexport const oceanZones: OceanZone[] = [\n  { tzid: 'Etc/GMT-12', left: 172.5, right: 180 },\n  { tzid: 'Etc/GMT-11', left: 157.5, right: 172.5 },\n  { tzid: 'Etc/GMT-10', left: 142.5, right: 157.5 },\n  { tzid: 'Etc/GMT-9', left: 127.5, right: 142.5 },\n  { tzid: 'Etc/GMT-8', left: 112.5, right: 127.5 },\n  { tzid: 'Etc/GMT-7', left: 97.5, right: 112.5 },\n  { tzid: 'Etc/GMT-6', left: 82.5, right: 97.5 },\n  { tzid: 'Etc/GMT-5', left: 67.5, right: 82.5 },\n  { tzid: 'Etc/GMT-4', left: 52.5, right: 67.5 },\n  { tzid: 'Etc/GMT-3', left: 37.5, right: 52.5 },\n  { tzid: 'Etc/GMT-2', left: 22.5, right: 37.5 },\n  { tzid: 'Etc/GMT-1', left: 7.5, right: 22.5 },\n  { tzid: 'Etc/GMT', left: -7.5, right: 7.5 },\n  { tzid: 'Etc/GMT+1', left: -22.5, right: -7.5 },\n  { tzid: 'Etc/GMT+2', left: -37.5, right: -22.5 },\n  { tzid: 'Etc/GMT+3', left: -52.5, right: -37.5 },\n  { tzid: 'Etc/GMT+4', left: -67.5, right: -52.5 },\n  { tzid: 'Etc/GMT+5', left: -82.5, right: -67.5 },\n  { tzid: 'Etc/GMT+6', left: -97.5, right: -82.5 },\n  { tzid: 'Etc/GMT+7', left: -112.5, right: -97.5 },\n  { tzid: 'Etc/GMT+8', left: -127.5, right: -112.5 },\n  { tzid: 'Etc/GMT+9', left: -142.5, right: -127.5 },\n  { tzid: 'Etc/GMT+10', left: -157.5, right: -142.5 },\n  { tzid: 'Etc/GMT+11', left: -172.5, right: -157.5 },\n  { tzid: 'Etc/GMT+12', left: -180, right: -172.5 },\n]\n\n/**\n * Find the Etc/GMT* timezone name(s) corresponding to the given longitue.\n *\n * @param lon The longitude to analyze\n * @returns An array of strings of TZIDs\n */\nexport function getTimezoneAtSea(lon: number): string[] {\n  // coordinates along the 180 longitude should return two zones\n  if (lon === -180 || lon === 180) {\n    return ['Etc/GMT+12', 'Etc/GMT-12']\n  }\n  const tzs = []\n  for (let i = 0; i < oceanZones.length; i++) {\n    const z = oceanZones[i]\n    if (z.left <= lon && z.right >= lon) {\n      tzs.push(z.tzid)\n    } else if (z.right < lon) {\n      break\n    }\n  }\n  return tzs\n}\n","import * as fs from 'fs'\nimport * as path from 'path'\n\nimport { decode } from 'geobuf'\nimport inside from '@turf/boolean-point-in-polygon'\nimport { point } from '@turf/helpers'\nimport Pbf from 'pbf'\n\nimport { getTimezoneAtSea, oceanZones } from './oceanUtils'\n\nconst tzData = require('../data/index.json')\n\nconst FEATURE_FILE_PATH = path.join(__dirname, '..', 'data', 'geo.dat')\nlet featureCache\n\ntype CacheOptions = {\n  /**\n   * If set to true, all features will be loaded into memory to shorten future lookup\n   * times.\n   */\n  preload?: boolean\n  /**\n   * Must be a map-like object with a `get` and `set` function.\n   */\n  store?: any\n}\n\n/**\n * Set caching behavior.\n *\n * @param {CacheOptions} options cachine options.\n */\nfunction cacheLevel(options?: CacheOptions) {\n  if (\n    options &&\n    options.store &&\n    typeof options.store.get === 'function' &&\n    typeof options.store.set === 'function'\n  ) {\n    featureCache = options.store\n  } else {\n    featureCache = new Map()\n  }\n  if (options && options.preload) {\n    const featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n\n    _preCache(featureFileFd)\n\n    fs.closeSync(featureFileFd)\n  }\n}\n\ncacheLevel()\n\n/**\n * A function that will load all features into an unexpiring cache\n *\n * @param {number} featureFileFd\n * @returns {void}\n */\nfunction _preCache(featureFileFd: number) {\n  // shoutout to github user @magwo for an initial version of this recursive function\n  function preloadFeaturesRecursive(curTzData, quadPos: string) {\n    if (curTzData.pos >= 0 && curTzData.len) {\n      const geoJson = loadFeatures(\n        quadPos,\n        curTzData.pos,\n        curTzData.len,\n        featureFileFd\n      )\n      featureCache.set(quadPos, geoJson)\n    } else if (typeof curTzData === 'object') {\n      Object.getOwnPropertyNames(curTzData).forEach(function (value) {\n        preloadFeaturesRecursive(curTzData[value], quadPos + value)\n      })\n    }\n  }\n  preloadFeaturesRecursive(tzData.lookup, '')\n}\n\n/**\n * Load features from geo.dat at offset pos with length len.\n * Optionally accept a file descriptor\n *\n * @param quadPos\n * @param pos\n * @param len\n * @param fd\n * @returns the GeoJSON features in within the given quad region as defined in the\n *  feature file data.\n */\nfunction loadFeatures(\n  quadPos: string,\n  pos: number,\n  len: number,\n  fd: number = -1\n) {\n  let featureFileFd = fd\n  if (featureFileFd < 0) {\n    featureFileFd = fs.openSync(FEATURE_FILE_PATH, 'r')\n    if (featureFileFd < 0) {\n      throw new Error('Failed to open geo.dat file')\n    }\n  }\n\n  // exact boundaries saved in file\n  // parse geojson for exact boundaries\n  const buf = Buffer.alloc(len)\n  const bytesRead = fs.readSync(featureFileFd, buf, 0, len, pos)\n\n  // close featureFileFd if we opened it\n  if (fd < 0) {\n    fs.closeSync(featureFileFd)\n  }\n\n  if (bytesRead < len) {\n    throw new Error(\n      `tried to read ${len} bytes from geo.dat but only got ${bytesRead} bytes`\n    )\n  }\n\n  const data = new Pbf(buf)\n  return decode(data)\n}\n\n/**\n * Find the timezone ID(s) at the given GPS coordinates.\n *\n * @param lat latitude (must be >= -90 and <=90)\n * @param lon longitue (must be >= -180 and <=180)\n * @returns An array of string of TZIDs at the given coordinate.\n */\nexport function find(lat: number, lon: number): string[] {\n  const originalLon = lon\n\n  let err\n\n  // validate latitude\n  if (isNaN(lat) || lat > 90 || lat < -90) {\n    err = new Error('Invalid latitude: ' + lat)\n    throw err\n  }\n\n  // validate longitude\n  if (isNaN(lon) || lon > 180 || lon < -180) {\n    err = new Error('Invalid longitude: ' + lon)\n    throw err\n  }\n\n  // North Pole should return all ocean zones\n  if (lat === 90) {\n    return oceanZones.map((zone) => zone.tzid)\n  }\n\n  // fix edges of the world\n  if (lat >= 89.9999) {\n    lat = 89.9999\n  } else if (lat <= -89.9999) {\n    lat = -89.9999\n  }\n\n  if (lon >= 179.9999) {\n    lon = 179.9999\n  } else if (lon <= -179.9999) {\n    lon = -179.9999\n  }\n\n  const pt = point([lon, lat])\n  const quadData = {\n    top: 89.9999,\n    bottom: -89.9999,\n    left: -179.9999,\n    right: 179.9999,\n    midLat: 0,\n    midLon: 0,\n  }\n  let quadPos = ''\n  let curTzData = tzData.lookup\n\n  while (true) {\n    // calculate next quadtree position\n    let nextQuad\n    if (lat >= quadData.midLat && lon >= quadData.midLon) {\n      nextQuad = 'a'\n      quadData.bottom = quadData.midLat\n      quadData.left = quadData.midLon\n    } else if (lat >= quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'b'\n      quadData.bottom = quadData.midLat\n      quadData.right = quadData.midLon\n    } else if (lat < quadData.midLat && lon < quadData.midLon) {\n      nextQuad = 'c'\n      quadData.top = quadData.midLat\n      quadData.right = quadData.midLon\n    } else {\n      nextQuad = 'd'\n      quadData.top = quadData.midLat\n      quadData.left = quadData.midLon\n    }\n\n    // console.log(nextQuad)\n    curTzData = curTzData[nextQuad]\n    // console.log()\n    quadPos += nextQuad\n\n    // analyze result of current depth\n    if (!curTzData) {\n      // no timezone in this quad, therefore must be timezone at sea\n      return getTimezoneAtSea(originalLon)\n    } else if (curTzData.pos >= 0 && curTzData.len) {\n      // get exact boundaries\n      let geoJson = featureCache.get(quadPos)\n      if (!geoJson) {\n        geoJson = loadFeatures(quadPos, curTzData.pos, curTzData.len)\n        featureCache.set(quadPos, geoJson)\n      }\n\n      const timezonesContainingPoint = []\n\n      for (let i = 0; i < geoJson.features.length; i++) {\n        if (inside(pt, geoJson.features[i])) {\n          timezonesContainingPoint.push(geoJson.features[i].properties.tzid)\n        }\n      }\n\n      // if at least one timezone contained the point, return those timezones,\n      // otherwise must be timezone at sea\n      return timezonesContainingPoint.length > 0\n        ? timezonesContainingPoint\n        : getTimezoneAtSea(originalLon)\n    } else if (curTzData.length > 0) {\n      // exact match found\n      return curTzData.map((idx) => tzData.timezones[idx])\n    } else if (typeof curTzData !== 'object') {\n      // not another nested quad index, throw error\n      err = new Error('Unexpected data type')\n      throw err\n    }\n\n    // calculate next quadtree depth data\n    quadData.midLat = (quadData.top + quadData.bottom) / 2\n    quadData.midLon = (quadData.left + quadData.right) / 2\n  }\n}\n\nexport { cacheLevel as setCache }\n\n/**\n * Load all features into memory to speed up future lookups.\n */\nexport function preCache() {\n  cacheLevel({ preload: true })\n}\n"]},"metadata":{},"sourceType":"module"}